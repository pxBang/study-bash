# 脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成

# 1. Shebang 行 # 
# 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。
# #!后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh或/bin/bash。

#!/bin/sh

#!/bin/bash

# 如果 Bash 解释器不放在目录/bin，脚本就无法执行了。为了保险，可以写成下面这样。

#!/usr/bin/env bash
# 上面命令使用env命令（这个命令总是在/usr/bin目录），返回 Bash 可执行文件的位置。env命令的详细介绍，请看后文。

# Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是script.sh，有 Shebang 行的时候，可以直接调用执行。
./script.sh
# 上面例子中，script.sh是脚本文件名。脚本通常使用.sh后缀名，不过这不是必需的。
# 如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。
/bin/sh ./script.sh
bash ./script.sh


# 2.执行权限和路径 #
# 前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。

chmod +x script.sh

# 3. env 命令 #
# env命令总是指向/usr/bin/env文件，或者说，这个二进制文件总是在目录/usr/bin。
# #!/usr/bin/env NAME这个语法的意思是，让 Shell 查找$PATH环境变量里面第一个匹配的NAME。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。
# /usr/bin/env bash的意思就是，返回bash可执行文件的位置，前提是bash的路径是在$PATH里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。
#!/usr/bin/env node


# 4. 注释 #
# Bash 脚本中，#表示注释，可以放在行首，也可以放在行尾。

# 5. 脚本参数 #
# 调用脚本的时候，脚本文件名后面可以带有参数。

script.sh word1 word2 word3

# 上面例子中，script.sh是一个脚本文件，word1、word2和word3是三个参数。脚本文件内部，可以使用特殊变量，引用这些参数。

# $0：脚本文件名，即script.sh。
# $1~$9：对应脚本的第一个参数到第九个参数。
# $#：参数的总数。
# $@：全部的参数，参数之间使用空格分隔。
# $*：全部的参数，参数之间使用变量$IFS值的第一个字符分隔，默认为空格，但是可以自定义。

# 如果脚本的参数多于9个，那么第10个参数可以用${10}的形式引用，以此类推。

# 注意，如果命令是command -o foo bar，那么-o是$1，foo是$2，bar是$3。

# 下面是一个脚本内部读取命令行参数的例子。
#!/bin/bash
# script.sh

echo "全部参数：" $@
echo "命令行参数数量：" $#
echo '$0 = ' $0
echo '$1 = ' $1
echo '$2 = ' $2
echo '$3 = ' $3

# 用户可以输入任意数量的参数，利用for循环，可以读取每一个参数。

#!/bin/bash

for i in "$@"; do
  echo $i
done

# 上面例子中，$@返回一个全部参数的列表，然后使用for循环遍历。

# 如果多个参数放在双引号里面，视为一个参数。
./script.sh "a b"
# 上面例子中，Bash 会认为"a b"是一个参数，$1会返回a b。注意，返回时不包括双引号。

# 6. shift 命令 #
# shift命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（$1），使得后面的参数向前一位，即$2变成$1、$3变成$2、$4变成$3，以此类推。
# while循环结合shift命令，也可以读取每一个参数。

#!/bin/bash

echo "一共输入了 $# 个参数"

while [ "$1" != "" ]; do
  echo "剩下 $# 个参数"
  echo "参数：$1"
  shift
done

# 上面例子中，shift命令每次移除当前第一个参数，从而通过while循环遍历所有参数。

# shift命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为1。

shift 3

# 上面的命令移除前三个参数，原来的$4变成$1。


# 7.getopts 命令 #
# 略，见原文

# 8.配置项参数终止符 -- # 
# 略，见原文

# 9. exit 命令 # 
# exit命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。
exit
# 上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。
# exit命令后面可以跟参数，该参数就是退出状态。

# 退出值为0（成功）
exit 0
# 退出值为1（失败）
exit 1

# 退出时，脚本会返回一个退出值。脚本的退出值，0表示正常，1表示发生错误，2表示用法不对，126表示不是可执行脚本，127表示命令没有发现。如果脚本被信号N终止，则退出值为128 + N。简单来说，只要退出值非0，就认为执行出错。

if [ $(id -u) != "0" ]; then
  echo "根用户才能执行当前脚本"
  exit 1
fi
# 上面的例子中，id -u命令返回用户的 ID，一旦用户的 ID 不等于0（根用户的 ID），脚本就会退出，并且退出码为1，表示运行失败。

# exit与return命令的差别是，return命令是函数的退出，并返回一个值给调用者，脚本依然执行。exit是整个脚本的退出，如果在函数之中调用exit，则退出函数，并终止脚本执行。

# 10. 命令执行结果 #
# 命令执行结束后，会有一个返回值。0表示执行成功，非0（通常是1）表示执行失败。环境变量$?可以读取前一个命令的返回值。
# 利用这一点，可以在脚本中对命令执行结果进行判断。

cd /path/to/somewhere
if [ "$?" = "0" ]; then
  exit 0
else
  echo "无法切换目录！" 1>&2
  exit 1
fi

# 上面例子中，cd /path/to/somewhere这个命令如果执行成功（返回值等于0），就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为1，表示执行失败。

# 由于if可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。

if cd /path/to/somewhere; then
  exit 0
else
  echo "Could not change directory! Aborting." 1>&2
  exit 1
fi

# 更简洁的写法是利用两个逻辑运算符&&（且）和||（或）。

# 第一步执行成功，才会执行第二步
cd /path/to/somewhere && rm *

# 第一步执行失败，才会执行第二步
cd /path/to/somewhere || exit 1

# 11. source 命令 #

# source命令用于执行一个脚本，通常用于重新加载一个配置文件。
# source .bashrc
# source命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，source命令执行脚本时，不需要export变量。

#!/bin/bash
# test.sh
echo $foo

# 上面脚本输出$foo变量的值。
# 当前 Shell 新建一个变量 foo
foo=1

# 打印输出 1
source test.sh

# 打印输出空字符串
bash test.sh

# 上面例子中，当前 Shell 的变量foo并没有export，所以直接执行无法读取，但是source执行可以读取。

# source命令的另一个用途，是在脚本内部加载外部库。

#!/bin/bash

source ./lib.sh

function_from_lib

#上面脚本在内部使用source命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。

# source有一个简写形式，可以使用一个点（.）来表示。
. .bashrc

# 12. 别名，alias 命令 #
# alias命令用来为一个命令指定别名，这样更便于记忆。下面是alias的格式。
alias NAME=DEFINITION
# 上面命令中，NAME是别名的名称，DEFINITION是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。
# 一个常见的例子是为grep命令起一个search的别名。
alias search=grep

# alias也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个today的命令。

alias today='date +"%A, %B %-d, %Y"'

# 有时为了防止误删除文件，可以指定rm命令的别名。
alias rm='rm -i'
# 上面命令指定rm命令是rm -i，每次删除文件之前，都会让用户确认。
# alias定义的别名也可以接受参数，参数会直接传入原始命令。

alias echo='echo It says: '
echo hello world

# 上面例子中，别名定义了echo命令的前两个参数，等同于修改了echo命令的默认行为。
# 指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在~/.bashrc的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。

# 直接调用alias命令，可以显示所有别名。
alias
# unalias命令可以解除别名。
unalias lt




